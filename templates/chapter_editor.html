<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter Editor - Honora</title>
    <style>
        :root {
            --bg-dark: #0f1419;
            --bg-card: #1a1f26;
            --bg-hover: #242b33;
            --bg-sidebar: #151a20;
            --text-primary: #f5f5f5;
            --text-muted: #8899a6;
            --accent: #7dd3fc;
            --accent-green: #4ade80;
            --accent-red: #f87171;
            --accent-yellow: #fbbf24;
            --accent-purple: #a78bfa;
            --border: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: sticky;
            top: 0;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .book-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .book-author {
            font-size: 13px;
            color: var(--text-muted);
        }

        .cover-preview {
            width: 100%;
            aspect-ratio: 2/3;
            background: var(--bg-card);
            border-radius: 8px;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 12px;
            overflow: hidden;
        }

        .cover-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .sidebar-section {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-section-title {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .chapter-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .chapter-item {
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chapter-item:hover {
            background: var(--bg-hover);
        }

        .chapter-item.active {
            background: rgba(125, 211, 252, 0.15);
            border-left: 3px solid var(--accent);
        }

        .chapter-item-title {
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chapter-item-meta {
            font-size: 11px;
            color: var(--text-muted);
        }

        .sidebar-footer {
            padding: 16px;
            border-top: 1px solid var(--border);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .chapter-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chapter-number {
            background: var(--accent);
            color: #000;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 13px;
        }

        .chapter-title-text {
            font-size: 18px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
        }

        .btn-primary:hover {
            opacity: 0.9;
        }

        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-success {
            background: var(--accent-green);
            color: #000;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            padding: 0 24px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
        }

        .tab {
            padding: 14px 24px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 14px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-count {
            background: var(--bg-hover);
            color: var(--text-muted);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 8px;
        }

        .tab.active .tab-count {
            background: rgba(125, 211, 252, 0.2);
            color: var(--accent);
        }

        /* Editor Container */
        .editor-container {
            flex: 1;
            padding: 32px 48px;
            overflow-y: auto;
            padding-bottom: 80px;
        }

        /* Metadata Section */
        .metadata-section {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid var(--border);
        }

        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        .metadata-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .metadata-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .metadata-input {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .metadata-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Document View */
        .document-view {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 32px 40px;
            min-height: 400px;
            border: 1px solid var(--border);
        }

        .document-editor {
            outline: none;
            line-height: 1.8;
            font-size: 16px;
            white-space: pre-wrap;
            min-height: 300px;
        }

        .document-editor:empty:before {
            content: 'Start writing or paste your chapter text here...';
            color: var(--text-muted);
        }

        /* Segments View */
        .segments-view {
            display: none;
        }

        .segments-view.active {
            display: block;
        }

        .segment {
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
            transition: all 0.2s;
        }

        .segment:hover {
            border-color: var(--accent);
        }

        .segment.overlength {
            border-color: var(--accent-red);
        }

        .segment-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
        }

        .segment-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .segment-bar {
            width: 4px;
            height: 24px;
            background: var(--accent-green);
            border-radius: 2px;
        }

        .segment.overlength .segment-bar {
            background: var(--accent-red);
        }

        .segment-bar.paragraph {
            background: var(--accent-purple);
        }

        .segment-index {
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 600;
        }

        .segment-header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .segment-chars {
            font-size: 13px;
            padding: 4px 10px;
            border-radius: 12px;
            background: var(--bg-hover);
        }

        .segment-chars.ok {
            background: rgba(74, 222, 128, 0.15);
            color: var(--accent-green);
        }

        .segment-chars.warn {
            background: rgba(251, 191, 36, 0.15);
            color: var(--accent-yellow);
        }

        .segment-chars.over {
            background: rgba(248, 113, 113, 0.15);
            color: var(--accent-red);
        }

        .segment-content {
            padding: 16px;
        }

        .segment-text {
            outline: none;
            line-height: 1.7;
            font-size: 15px;
            white-space: pre-wrap;
        }

        .segment-actions {
            display: flex;
            gap: 8px;
            padding: 0 16px 12px;
        }

        .segment-btn {
            padding: 6px 12px;
            background: var(--bg-hover);
            border: none;
            color: var(--text-muted);
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .segment-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 280px;
            right: 0;
            padding: 12px 24px;
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-muted);
        }

        .status-stats {
            display: flex;
            gap: 24px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
        }

        .status-indicator.warning {
            background: var(--accent-yellow);
        }

        .status-indicator.error {
            background: var(--accent-red);
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <div class="book-title" id="book-title">Loading...</div>
            <div class="book-author" id="book-author"></div>
            <div class="cover-preview" id="cover-preview">No cover</div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-section-title">Metadata</div>
            <div style="display: flex; flex-direction: column; gap: 8px">
                <button class="btn btn-secondary btn-small" onclick="toggleMetadata()" style="width: 100%">
                    ‚úèÔ∏è Edit Metadata
                </button>
                <button class="btn btn-secondary btn-small" onclick="aiLookupMetadata()" style="width: 100%">
                    ü§ñ AI Lookup
                </button>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-section-title">Chapters (<span id="chapter-count">0</span>)</div>
        </div>

        <div class="chapter-list" id="chapter-list">
            <!-- Populated by JS -->
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-success" onclick="commitToSupabase()" style="width: 100%">
                üì§ Upload to Supabase
            </button>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Metadata Editor (hidden by default) -->
        <div id="metadata-editor" class="hidden">
            <div class="editor-container">
                <div class="metadata-section">
                    <div class="sidebar-section-title" style="margin-bottom: 16px">Book Metadata</div>
                    <div class="metadata-grid">
                        <div class="metadata-field">
                            <label class="metadata-label">Title</label>
                            <input type="text" class="metadata-input" id="meta-title" oninput="onMetadataChange()">
                        </div>
                        <div class="metadata-field">
                            <label class="metadata-label">Author</label>
                            <input type="text" class="metadata-input" id="meta-author" oninput="onMetadataChange()">
                        </div>
                        <div class="metadata-field">
                            <label class="metadata-label">Language</label>
                            <input type="text" class="metadata-input" id="meta-language" oninput="onMetadataChange()">
                        </div>
                        <div class="metadata-field">
                            <label class="metadata-label">Category</label>
                            <input type="text" class="metadata-input" id="meta-category" oninput="onMetadataChange()">
                        </div>
                        <div class="metadata-field">
                            <label class="metadata-label">Publisher</label>
                            <input type="text" class="metadata-input" id="meta-publisher" oninput="onMetadataChange()">
                        </div>
                        <div class="metadata-field">
                            <label class="metadata-label">Year</label>
                            <input type="text" class="metadata-input" id="meta-year" oninput="onMetadataChange()">
                        </div>
                    </div>
                    <div class="metadata-field" style="margin-top: 16px">
                        <label class="metadata-label">Synopsis <button class="btn btn-secondary btn-small"
                                onclick="aiGenerateSynopsis()"
                                style="padding: 4px 8px; font-size: 11px; margin-left: 8px;">ü§ñ AI
                                Generate</button></label>
                        <textarea class="metadata-input" id="meta-synopsis" rows="3" style="resize: vertical"
                            oninput="onMetadataChange()"></textarea>
                    </div>
                    <div style="margin-top: 16px; display: flex; gap: 12px">
                        <button class="btn btn-primary" onclick="saveMetadata()">üíæ Save Metadata</button>
                        <button class="btn btn-secondary" onclick="toggleMetadata()">‚Üê Back</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chapter Editor -->
        <div id="chapter-editor">
            <!-- Header -->
            <header class="header">
                <div class="header-left">
                    <div class="chapter-indicator">
                        <span class="chapter-number" id="current-chapter-num">Ch. 0</span>
                        <span class="chapter-title-text" id="chapter-title">Select a chapter</span>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="btn btn-secondary" onclick="optimizeAll()">‚ú® Optimize All</button>
                    <button class="btn btn-primary" onclick="saveChapter()">üíæ Save</button>
                </div>
            </header>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" data-view="document" onclick="switchTab('document')">üìÑ Document</button>
                <button class="tab" data-view="sections" onclick="switchTab('sections')">
                    üîñ Sections <span class="tab-count" id="section-count">0</span>
                </button>
                <button class="tab" data-view="paragraphs" onclick="switchTab('paragraphs')">
                    üìù Paragraphs <span class="tab-count" id="paragraph-count">0</span>
                </button>
            </div>

            <!-- Editor Container -->
            <div class="editor-container">
                <div id="document-view" class="document-view">
                    <div class="document-editor" id="document-editor" contenteditable="true" spellcheck="true"></div>
                </div>

                <div id="sections-view" class="segments-view">
                    <div id="sections-list"></div>
                </div>

                <div id="paragraphs-view" class="segments-view">
                    <div id="paragraphs-list"></div>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-stats">
                <div class="status-item">
                    <span class="status-indicator" id="save-indicator"></span>
                    <span id="save-status">Ready</span>
                </div>
                <div class="status-item">Total: <span id="total-chars">0</span> chars</div>
                <div class="status-item">Sections: <span id="total-sections">0</span></div>
                <div class="status-item">Overlength: <span id="overlength-count">0</span></div>
            </div>
            <div class="status-item"><span id="cursor-position">Line 1, Col 1</span></div>
        </div>
    </main>

    <!-- AI Confirmation Modal -->
    <div id="ai-confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <h3 id="ai-modal-title">AI Generated Data</h3>
            <p style="color: var(--text-muted); margin-bottom: 16px;">Review the AI-generated data below. Click Apply to
                update fields.</p>

            <div id="ai-preview-content"
                style="background: var(--bg-hover); padding: 16px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
                <!-- Preview content will be inserted here -->
            </div>

            <div style="display: flex; gap: 12px; margin-top: 20px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closeAiModal()">Cancel</button>
                <button class="btn btn-primary" onclick="applyAiData()">‚úì Apply</button>
            </div>
        </div>
    </div>

    <style>
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 24px;
            border: 1px solid var(--border);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-content h3 {
            margin-bottom: 8px;
            color: var(--accent);
        }

        .ai-preview-row {
            display: flex;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .ai-preview-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .ai-preview-label {
            width: 120px;
            font-weight: 600;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .ai-preview-value {
            color: var(--text-primary);
            flex: 1;
        }

        .ai-preview-value.synopsis {
            white-space: pre-wrap;
            line-height: 1.5;
        }
    </style>

    <script>
        // ============================================
        // STATE
        // ============================================
        const state = {
            jobId: null,
            chapters: [],
            currentChapter: null,
            currentChapterIndex: 0,
            metadata: {},
            text: '',
            sections: [],
            paragraphs: [],
            dirty: false,
            metadataDirty: false,
            currentView: 'document',
            maxSectionChars: 250,
            autoSaveTimeout: null,
            isSaving: false,
            lastSaved: null,
            pendingAiData: null  // Stores AI-generated data pending user confirmation
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            const params = new URLSearchParams(window.location.search);
            state.jobId = params.get('job_id');
            state.currentChapterIndex = parseInt(params.get('chapter')) || 0;

            if (state.jobId) {
                loadJob();
            } else {
                loadDemoData();
            }

            const editor = document.getElementById('document-editor');
            editor.addEventListener('input', onTextChange);
            editor.addEventListener('keyup', updateCursorPosition);
            editor.addEventListener('mouseup', updateCursorPosition);
            document.addEventListener('keydown', handleKeyboard);

            // Warn before leaving with unsaved changes
            window.addEventListener('beforeunload', (e) => {
                if (state.dirty) {
                    e.preventDefault();
                    e.returnValue = 'You have unsaved changes!';
                    return e.returnValue;
                }
            });
        });

        // ============================================
        // KEYBOARD SHORTCUTS
        // ============================================
        function handleKeyboard(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); saveChapter(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'o') { e.preventDefault(); optimizeAll(); }
        }

        // ============================================
        // DATA LOADING
        // ============================================
        async function loadJob() {
            try {
                const res = await fetch(`/v2/job/${state.jobId}`);
                const data = await res.json();

                state.metadata = data.metadata || {};
                state.chapters = data.chapters || [];

                updateSidebar();
                if (state.chapters.length > 0) {
                    selectChapter(state.currentChapterIndex);
                }
            } catch (e) {
                console.error('Failed to load job:', e);
            }
        }

        function loadDemoData() {
            state.metadata = {
                title: 'The Kybalion',
                author: 'Three Initiates',
                language: 'English',
                category: 'Philosophy'
            };
            state.chapters = [
                { index: 0, title: 'Introduction', content: 'This is the introduction chapter...', section_count: 5 },
                { index: 1, title: 'The Hermetic Philosophy', content: 'We take great pleasure in presenting to the attention of students and investigators of the Secret Doctrines this little work based upon the world-old Hermetic Teachings.\n\nThere has been so little written upon this subject, notwithstanding the countless references to the teachings in the many works upon occultism, that the many earnest searchers after the Arcane Truths will doubtless welcome the appearance of this present volume.\n\nThe purpose of this work is not the enunciation of any special philosophy or doctrine, but rather is to give to the students a statement of the Truth that will serve to reconcile the many bits of occult knowledge that they may have acquired.', section_count: 12 },
                { index: 2, title: 'The Seven Hermetic Principles', content: 'The seven principles upon which Hermetic Philosophy is based...', section_count: 8 }
            ];
            updateSidebar();
            selectChapter(1);
        }

        function updateSidebar() {
            // Book info
            document.getElementById('book-title').textContent = state.metadata.title || 'Untitled';
            document.getElementById('book-author').textContent = state.metadata.author || '';
            document.getElementById('chapter-count').textContent = state.chapters.length;

            // Cover preview
            const coverEl = document.getElementById('cover-preview');
            if (state.metadata.cover_art_url) {
                coverEl.innerHTML = `<img src="${state.metadata.cover_art_url}" alt="Cover">`;
            } else {
                coverEl.textContent = 'No cover';
            }

            // Chapter list
            const listEl = document.getElementById('chapter-list');
            listEl.innerHTML = state.chapters.map((ch, i) => `
                <div class="chapter-item ${i === state.currentChapterIndex ? 'active' : ''}" onclick="selectChapter(${i})">
                    <div>
                        <div class="chapter-item-title">Ch. ${ch.index}: ${ch.title || 'Untitled'}</div>
                        <div class="chapter-item-meta">${ch.section_count || 0} sections</div>
                    </div>
                </div>
            `).join('');
        }

        // ============================================
        // CHAPTER SELECTION
        // ============================================
        async function selectChapter(arrayIndex) {
            // Cancel any pending auto-save
            if (state.autoSaveTimeout) {
                clearTimeout(state.autoSaveTimeout);
                state.autoSaveTimeout = null;
            }

            // Save current chapter if dirty before switching
            if (state.dirty && state.jobId && !state.isSaving) {
                updateStatus('Saving before switch...', true);
                await saveChapter();
            }

            // Wait for any in-progress save to complete
            while (state.isSaving) {
                await new Promise(r => setTimeout(r, 100));
            }

            state.currentChapterIndex = arrayIndex;

            // Get the actual chapter from the array
            const chapter = state.chapters[arrayIndex];
            if (!chapter) {
                console.error('Chapter not found at index:', arrayIndex);
                return;
            }

            // Use the chapter's actual index for API calls (not the array position!)
            const chapterIndex = chapter.index;

            // CRITICAL: Load fresh data from server, not from potentially stale client state
            if (state.jobId) {
                try {
                    const res = await fetch(`/v2/job/${state.jobId}/chapter/${chapterIndex}/text`);
                    const chapterData = await res.json();

                    if (chapterData.error) {
                        console.error('Server error loading chapter:', chapterData.error);
                    } else {
                        // Update the chapter in our list
                        chapter.content = chapterData.text;
                        chapter.sections = chapterData.sections;
                        chapter.paragraphs = chapterData.paragraphs;
                    }

                    state.currentChapter = chapter;
                    state.text = chapterData.text || chapter.content || '';
                    state.sections = chapterData.sections || chapter.sections || [];
                    state.paragraphs = chapterData.paragraphs || chapter.paragraphs || [];
                } catch (e) {
                    console.error('Failed to load chapter from server:', e);
                    // Fallback to client state
                    state.currentChapter = chapter;
                    state.text = chapter.content || '';
                    state.sections = chapter.sections || [];
                    state.paragraphs = chapter.paragraphs || [];
                }
            } else {
                state.currentChapter = chapter;
                state.text = chapter.content || '';
            }

            state.dirty = false;

            // Update UI - use the chapter's actual index for display
            document.getElementById('current-chapter-num').textContent = `Ch. ${chapterIndex}`;
            document.getElementById('chapter-title').textContent = state.currentChapter?.title || 'Untitled';
            document.getElementById('document-editor').innerText = state.text;

            // Update sidebar active state
            document.querySelectorAll('.chapter-item').forEach((el, i) => {
                el.classList.toggle('active', i === arrayIndex);
            });

            renderSections();
            renderParagraphs();
            updateStatus('Ready', false);
        }

        // ============================================
        // METADATA
        // ============================================
        function toggleMetadata() {
            const metaEditor = document.getElementById('metadata-editor');
            const chapterEditor = document.getElementById('chapter-editor');
            const isHidden = metaEditor.classList.contains('hidden');

            if (isHidden) {
                // Load metadata into form
                document.getElementById('meta-title').value = state.metadata.title || '';
                document.getElementById('meta-author').value = state.metadata.author || '';
                document.getElementById('meta-language').value = state.metadata.language || '';
                document.getElementById('meta-category').value = state.metadata.category || '';
                document.getElementById('meta-publisher').value = state.metadata.publisher || '';
                document.getElementById('meta-year').value = state.metadata.publishing_year || '';
                document.getElementById('meta-synopsis').value = state.metadata.synopsis || '';
            }

            metaEditor.classList.toggle('hidden');
            chapterEditor.classList.toggle('hidden');
        }

        function onMetadataChange() {
            state.metadataDirty = true;
        }

        async function saveMetadata() {
            state.metadata.title = document.getElementById('meta-title').value;
            state.metadata.author = document.getElementById('meta-author').value;
            state.metadata.language = document.getElementById('meta-language').value;
            state.metadata.category = document.getElementById('meta-category').value;
            state.metadata.publisher = document.getElementById('meta-publisher').value;
            state.metadata.publishing_year = document.getElementById('meta-year').value;
            state.metadata.synopsis = document.getElementById('meta-synopsis').value;

            if (state.jobId) {
                try {
                    await fetch(`/v2/job/${state.jobId}/metadata`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(state.metadata)
                    });
                    alert('Metadata saved!');
                } catch (e) {
                    alert('Failed to save metadata');
                }
            }

            state.metadataDirty = false;
            updateSidebar();
            toggleMetadata();
        }

        // ============================================
        // TEXT EDITING
        // ============================================
        function onTextChange() {
            const editor = document.getElementById('document-editor');
            let rawText = editor.innerText;

            // Normalize whitespace: collapse multiple newlines to max 2, trim lines
            state.text = rawText
                .replace(/\n{3,}/g, '\n\n')  // Collapse 3+ newlines to 2
                .replace(/[ \t]+\n/g, '\n')  // Remove trailing spaces before newlines
                .replace(/\n[ \t]+/g, '\n')  // Remove leading spaces after newlines
                .trim();

            state.dirty = true;
            updateStatus('Unsaved changes...', true);
            document.getElementById('total-chars').textContent = state.text.length.toLocaleString();

            // Re-segment text for sections/paragraphs display
            segmentText();
            renderSections();
            renderParagraphs();

            // DEBOUNCED AUTO-SAVE: Save 2 seconds after user stops typing
            if (state.autoSaveTimeout) {
                clearTimeout(state.autoSaveTimeout);
            }
            if (state.jobId) {
                state.autoSaveTimeout = setTimeout(() => {
                    saveChapter();
                }, 2000);
            }
        }

        function segmentText() {
            // Get chapter title
            const chapterTitle = state.currentChapter?.title ?
                `Chapter ${state.currentChapter.index}: ${state.currentChapter.title}` : '';

            // Split text into sentences for sections
            const sentences = state.text.split(/(?<=[.!?])\s+/);
            state.sections = [];

            // Section 1 is always the chapter title
            if (chapterTitle) {
                state.sections.push(chapterTitle);
            }

            let currentSection = '';
            for (const sentence of sentences) {
                if ((currentSection + ' ' + sentence).trim().length <= state.maxSectionChars) {
                    currentSection = (currentSection + ' ' + sentence).trim();
                } else {
                    if (currentSection) state.sections.push(currentSection);
                    currentSection = sentence;
                }
            }
            if (currentSection) state.sections.push(currentSection);

            // Paragraphs - also start with chapter title
            const textParagraphs = state.text.split(/\n\n+/).filter(p => p.trim());
            state.paragraphs = chapterTitle ? [chapterTitle, ...textParagraphs] : textParagraphs;

            document.getElementById('section-count').textContent = state.sections.length;
            document.getElementById('paragraph-count').textContent = state.paragraphs.length;
            document.getElementById('total-sections').textContent = state.sections.length;

            const overlength = state.sections.filter(s => s.length > state.maxSectionChars).length;
            document.getElementById('overlength-count').textContent = overlength;
        }

        // ============================================
        // RENDERING
        // ============================================
        function renderSections() {
            const container = document.getElementById('sections-list');
            container.innerHTML = state.sections.map((text, i) => {
                const chars = text.length;
                const isOver = chars > state.maxSectionChars;
                const charClass = isOver ? 'over' : (chars > 200 ? 'warn' : 'ok');
                const isTitle = i === 0;
                return `
                    <div class="segment ${isOver ? 'overlength' : ''}">
                        <div class="segment-header">
                            <div class="segment-header-left">
                                <div class="segment-bar"></div>
                                <span class="segment-index">¬ß${i + 1}</span>
                            </div>
                            <div class="segment-header-right">
                                <span class="segment-chars ${charClass}">${chars}/${state.maxSectionChars}</span>
                            </div>
                        </div>
                        <div class="segment-content">
                            <div class="segment-text" contenteditable="true" oninput="onSectionEdit(${i}, this.innerText)">${escapeHtml(text)}</div>
                        </div>
                        <div class="segment-actions">
                            <button class="segment-btn" onclick="splitSection(${i})">‚úÇÔ∏è Split</button>
                            ${i > 0 ? `<button class="segment-btn" onclick="mergeWithPrevious(${i})">üîó Merge ‚Üë</button>` : ''}
                            <button class="segment-btn" onclick="optimizeSegment('section', ${i})">‚ú® Optimize</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderParagraphs() {
            const container = document.getElementById('paragraphs-list');
            container.innerHTML = state.paragraphs.map((text, i) => {
                const chars = text.length;
                const isTitle = i === 0;
                return `
                    <div class="segment ${isTitle ? 'title-segment' : ''}">
                        <div class="segment-header">
                            <div class="segment-header-left">
                                <div class="segment-bar paragraph"></div>
                                <span class="segment-index">${isTitle ? 'üìå Title' : `¬∂${i}`}</span>
                            </div>
                            <div class="segment-header-right">
                                <span class="segment-chars">${chars} chars</span>
                            </div>
                        </div>
                        <div class="segment-content">
                            <div class="segment-text" contenteditable="true" oninput="onParagraphEdit(${i}, this.innerText)">${escapeHtml(text)}</div>
                        </div>
                        <div class="segment-actions">
                            <button class="segment-btn" onclick="optimizeSegment('paragraph', ${i})">‚ú® Optimize</button>
                            ${!isTitle ? `<button class="segment-btn" onclick="deleteParagraph(${i})">üóëÔ∏è Delete</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ============================================
        // ACTIONS
        // ============================================
        function switchTab(view) {
            state.currentView = view;
            document.querySelectorAll('.tab').forEach(tab => tab.classList.toggle('active', tab.dataset.view === view));
            document.getElementById('document-view').classList.toggle('hidden', view !== 'document');
            document.getElementById('sections-view').classList.toggle('hidden', view !== 'sections');
            document.getElementById('sections-view').classList.toggle('active', view === 'sections');
            document.getElementById('paragraphs-view').classList.toggle('hidden', view !== 'paragraphs');
            document.getElementById('paragraphs-view').classList.toggle('active', view === 'paragraphs');
        }

        function onSectionEdit(index, newText) {
            state.sections[index] = newText;
            state.dirty = true;
            state.text = state.sections.join(' ');
            document.getElementById('document-editor').innerText = state.text;
            renderSections();
        }

        function onParagraphEdit(index, newText) {
            state.paragraphs[index] = newText;
            state.dirty = true;
            state.text = state.paragraphs.join('\n\n');
            document.getElementById('document-editor').innerText = state.text;
        }

        function splitSection(index) {
            const text = state.sections[index];

            // Try to get cursor position from the contenteditable
            const selection = window.getSelection();
            let splitPoint = Math.floor(text.length / 2);

            // If user has cursor in section text, split at cursor
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const sectionEl = document.querySelector(`.segment:nth-child(${index + 1}) .segment-text`);
                if (sectionEl && sectionEl.contains(range.startContainer)) {
                    splitPoint = range.startOffset;
                }
            }

            // If no cursor, find nearest sentence boundary
            if (splitPoint === Math.floor(text.length / 2)) {
                const nearestPeriod = text.lastIndexOf('.', splitPoint);
                if (nearestPeriod > splitPoint / 2) splitPoint = nearestPeriod + 1;
            }

            const part1 = text.substring(0, splitPoint).trim();
            const part2 = text.substring(splitPoint).trim();

            if (part1 && part2) {
                state.sections.splice(index, 1, part1, part2);
                renderSections();
                state.dirty = true;
                updateStatus('Section split - click Save', true);
            }
        }

        function mergeWithPrevious(index) {
            if (index < 1) return;
            state.sections.splice(index - 1, 2, state.sections[index - 1] + ' ' + state.sections[index]);
            renderSections();
            state.dirty = true;
            updateStatus('Sections merged - click Save', true);
        }

        function deleteParagraph(index) {
            if (index === 0) return; // Cannot delete title
            if (!confirm(`Delete paragraph ${index}?`)) return;
            state.paragraphs.splice(index, 1);
            // Rebuild text without chapter title
            state.text = state.paragraphs.slice(1).join('\n\n');
            document.getElementById('document-editor').innerText = state.text;
            renderParagraphs();
            state.dirty = true;
            updateStatus('Paragraph deleted - click Save', true);
        }

        async function optimizeSegment(type, index) {
            if (!state.jobId) { alert('Demo mode - optimize disabled'); return; }
            // TODO: Implement single segment optimization via API
            alert(`Optimizing ${type} ${index + 1}...`);
        }

        async function optimizeAll() {
            if (!state.jobId) { alert('Demo mode - optimize disabled'); return; }
            try {
                updateStatus('Optimizing...', true);
                const res = await fetch(`/v2/job/${state.jobId}/chapter/${state.currentChapterIndex}/optimize`, { method: 'POST' });
                const data = await res.json();
                if (data.text) {
                    state.text = data.text;
                    document.getElementById('document-editor').innerText = state.text;
                    onTextChange();
                    updateStatus('Optimized!', false);
                } else {
                    updateStatus('Optimization returned no text', true);
                }
            } catch (e) {
                updateStatus('Optimize failed', true);
                console.error('Optimize error:', e);
            }
        }

        // AI Lookup Metadata
        async function aiLookupMetadata() {
            if (!state.jobId) { alert('Demo mode - AI disabled'); return; }
            const title = document.getElementById('meta-title').value || state.metadata.title || '';
            if (!title) { alert('Enter a book title first'); return; }
            try {
                updateStatus('Looking up metadata...', true);
                const res = await fetch(`/v2/job/${state.jobId}/ai-metadata-lookup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title })
                });
                const data = await res.json();

                if (data.error) {
                    updateStatus('AI lookup failed: ' + data.error, true);
                    return;
                }

                // Store pending data and show modal
                state.pendingAiData = { type: 'metadata', data };
                showAiConfirmModal('AI Metadata Lookup', data);
                updateStatus('Review AI data...', false);
            } catch (e) {
                console.error('AI lookup failed:', e);
                updateStatus('AI lookup failed', true);
            }
        }

        // AI Generate Synopsis
        async function aiGenerateSynopsis() {
            if (!state.jobId) { alert('Demo mode - AI disabled'); return; }
            const title = document.getElementById('meta-title').value || state.metadata.title || '';
            if (!title) { alert('Enter a book title first'); return; }
            try {
                updateStatus('Generating synopsis...', true);
                const res = await fetch(`/v2/job/${state.jobId}/ai-synopsis`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, author: document.getElementById('meta-author').value || state.metadata.author })
                });
                const data = await res.json();

                if (data.error) {
                    updateStatus('AI synopsis failed: ' + data.error, true);
                    return;
                }

                // Store pending data and show modal
                state.pendingAiData = { type: 'synopsis', data };
                showAiConfirmModal('AI Generated Synopsis', data);
                updateStatus('Review AI data...', false);
            } catch (e) {
                console.error('AI synopsis failed:', e);
                updateStatus('AI synopsis failed', true);
            }
        }

        // Show AI confirmation modal
        function showAiConfirmModal(title, data) {
            document.getElementById('ai-modal-title').textContent = title;

            let previewHtml = '';

            if (data.author) {
                previewHtml += `<div class="ai-preview-row"><span class="ai-preview-label">Author:</span><span class="ai-preview-value">${escapeHtml(data.author)}</span></div>`;
            }
            if (data.publishing_year) {
                previewHtml += `<div class="ai-preview-row"><span class="ai-preview-label">Year:</span><span class="ai-preview-value">${escapeHtml(data.publishing_year)}</span></div>`;
            }
            if (data.publisher) {
                previewHtml += `<div class="ai-preview-row"><span class="ai-preview-label">Publisher:</span><span class="ai-preview-value">${escapeHtml(data.publisher)}</span></div>`;
            }
            if (data.category) {
                previewHtml += `<div class="ai-preview-row"><span class="ai-preview-label">Category:</span><span class="ai-preview-value">${escapeHtml(data.category)}</span></div>`;
            }
            if (data.synopsis) {
                previewHtml += `<div class="ai-preview-row"><span class="ai-preview-label">Synopsis:</span><span class="ai-preview-value synopsis">${escapeHtml(data.synopsis)}</span></div>`;
            }

            if (!previewHtml) {
                previewHtml = '<p style="color: var(--text-muted);">No data found.</p>';
            }

            document.getElementById('ai-preview-content').innerHTML = previewHtml;
            document.getElementById('ai-confirm-modal').style.display = 'flex';
        }

        // Close AI modal
        function closeAiModal() {
            document.getElementById('ai-confirm-modal').style.display = 'none';
            state.pendingAiData = null;
            updateStatus('Ready', false);
        }

        // Apply AI data to form fields
        function applyAiData() {
            if (!state.pendingAiData) return;

            const { type, data } = state.pendingAiData;

            if (type === 'metadata') {
                if (data.author) document.getElementById('meta-author').value = data.author;
                if (data.publishing_year) document.getElementById('meta-year').value = data.publishing_year;
                if (data.publisher) document.getElementById('meta-publisher').value = data.publisher;
                if (data.category) document.getElementById('meta-category').value = data.category;
            }

            if (type === 'synopsis' && data.synopsis) {
                document.getElementById('meta-synopsis').value = data.synopsis;
            }

            state.metadataDirty = true;
            closeAiModal();
            updateStatus('AI data applied! Click Save Metadata to save.', false);
        }

        async function saveChapter() {
            if (!state.jobId) { alert('Demo mode - save disabled'); return; }
            if (state.isSaving) return; // Prevent duplicate saves
            if (!state.currentChapter) { console.error('No current chapter'); return; }

            state.isSaving = true;
            updateStatus('Saving...', true);

            // Use the chapter's actual index, not the array position
            const chapterIndex = state.currentChapter.index;

            try {
                const res = await fetch(`/v2/job/${state.jobId}/chapter/${chapterIndex}/text`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: state.text,
                        sections: state.sections,
                        paragraphs: state.paragraphs
                    })
                });

                const data = await res.json();

                // CRITICAL: Sync client state with server response
                if (data.chapter) {
                    // Update the chapter in the chapters list
                    const idx = state.chapters.findIndex(c => c.index === chapterIndex);
                    if (idx >= 0) {
                        state.chapters[idx] = { ...state.chapters[idx], ...data.chapter };
                        state.currentChapter = state.chapters[idx];
                    }

                    // Sync all state fields
                    state.text = data.chapter.content || state.text;
                    state.sections = data.chapter.sections || state.sections;
                    state.paragraphs = data.chapter.paragraphs || state.paragraphs;
                }

                state.dirty = false;
                state.lastSaved = new Date();
                updateSidebar();
                updateStatus(`Saved at ${state.lastSaved.toLocaleTimeString()}`, false);

            } catch (e) {
                console.error('Save failed:', e);
                updateStatus('Save failed!', true);
            } finally {
                state.isSaving = false;
            }
        }

        async function commitToSupabase() {
            if (!state.jobId) { alert('Demo mode - commit disabled'); return; }
            if (state.dirty) { alert('Please save your changes first!'); return; }
            if (!confirm('Upload all chapters and metadata to Supabase?\n\nThis will publish the book.')) return;

            // Show loading overlay
            showUploadingModal();

            try {
                updateStatus('Uploading to Supabase...', true);
                const res = await fetch(`/v2/job/${state.jobId}/commit`, { method: 'POST' });
                const data = await res.json();

                hideUploadingModal();

                if (data.error) {
                    updateStatus('Upload failed: ' + data.error, true);
                    alert('Upload failed: ' + data.error);
                } else {
                    updateStatus('Upload complete!', false);
                    showSuccessModal(data.book_id);
                }
            } catch (e) {
                hideUploadingModal();
                updateStatus('Upload failed', true);
                alert('Commit failed: ' + e.message);
            }
        }

        function showUploadingModal() {
            const modal = document.createElement('div');
            modal.id = 'upload-modal';
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 400px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">üì§</div>
                    <h3 style="margin-bottom: 8px;">Uploading to Supabase...</h3>
                    <p style="color: var(--text-muted);">Please wait while your book is being published.</p>
                    <div style="margin-top: 20px;">
                        <div style="width: 100%; height: 4px; background: var(--bg-hover); border-radius: 2px; overflow: hidden;">
                            <div style="width: 30%; height: 100%; background: var(--accent); animation: loading 1.5s ease-in-out infinite;"></div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Add loading animation
            if (!document.getElementById('loading-animation-style')) {
                const style = document.createElement('style');
                style.id = 'loading-animation-style';
                style.textContent = `
                    @keyframes loading {
                        0% { margin-left: 0%; width: 30%; }
                        50% { margin-left: 35%; width: 30%; }
                        100% { margin-left: 70%; width: 30%; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function hideUploadingModal() {
            const modal = document.getElementById('upload-modal');
            if (modal) modal.remove();
        }

        function showSuccessModal(bookId) {
            const modal = document.createElement('div');
            modal.id = 'success-modal';
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content" style="text-align: center; max-width: 450px;">
                    <div style="font-size: 64px; margin-bottom: 16px;">‚úÖ</div>
                    <h3 style="margin-bottom: 8px; color: var(--accent-green);">Upload Complete!</h3>
                    <p style="color: var(--text-muted); margin-bottom: 16px;">Your book has been published to Supabase.</p>
                    <div style="background: var(--bg-hover); padding: 12px; border-radius: 8px; margin-bottom: 20px;">
                        <span style="color: var(--text-muted); font-size: 12px;">Book ID:</span><br>
                        <code style="color: var(--accent); font-family: monospace;">${bookId}</code>
                    </div>
                    <button class="btn btn-primary" onclick="document.getElementById('success-modal').remove()">Done</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function updateStatus(text, isWarning) {
            document.getElementById('save-status').textContent = text;
            document.getElementById('save-indicator').classList.toggle('warning', isWarning);
        }

        function updateCursorPosition() {
            const editor = document.getElementById('document-editor');
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const text = editor.innerText.substring(0, range.startOffset);
            const lines = text.split('\n');
            document.getElementById('cursor-position').textContent = `Line ${lines.length}, Col ${lines[lines.length - 1].length + 1}`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>

</html>